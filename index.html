<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEON BREAKER // HACKER MODE</title>
    <style>
        :root { --neon: #00f2ff; --pink: #ff00ff; --bg: #050508; }
        body { background: var(--bg); color: white; margin: 0; font-family: 'Courier New', monospace; overflow: hidden; }
        
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }

        /* Terminal Overlay */
        #terminal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; background: rgba(0, 0, 0, 0.9); border: 2px solid var(--neon);
            padding: 30px; display: none; text-align: center; z-index: 100;
            box-shadow: 0 0 50px var(--neon);
        }
        #prompt { color: var(--pink); font-size: 1.5rem; margin-bottom: 10px; }
        #typing-input { 
            background: transparent; border: none; border-bottom: 2px solid var(--neon);
            color: white; font-family: inherit; font-size: 1.5rem; text-align: center;
            outline: none; width: 100%;
        }

        /* Glitch UI */
        .hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; pointer-events: none; }
        .glitch-text { text-shadow: 2px 0 var(--pink), -2px 0 var(--neon); animation: glitch 1s infinite; }
        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
    </style>
</head>
<body>

<div id="game-container">
    <div class="hud">
        <div class="glitch-text">SYSTEM_STATUS: <span id="mode">STABLE</span></div>
        <div>SCORE: <span id="score">0</span></div>
    </div>

    <div id="terminal">
        <div id="prompt">TYPE: OVERRIDE</div>
        <input type="text" id="typing-input" autocomplete="off">
        <div style="font-size: 10px; margin-top: 10px; color: #555;">[SECURE TUNNEL ACTIVE]</div>
    </div>

    <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const term = document.getElementById('terminal');
const input = document.getElementById('typing-input');
const promptEl = document.getElementById('prompt');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = { x: canvas.width/2, y: canvas.height/2, size: 10, speed: 5 };
let enemies = [];
let isHacking = false;
let score = 0;
let currentCommand = "";
let commands = ["OVERRIDE", "BYPASS", "DECRYPT", "TERMINATE", "PURGE"];
let shockwave = { r: 0, active: false };

function spawnEnemy() {
    if (isHacking) return;
    enemies.push({
        x: Math.random() * canvas.width,
        y: Math.random() < 0.5 ? -20 : canvas.height + 20,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4
    });
}

// Every 5 seconds, force a hack
setInterval(() => {
    if (!isHacking) startHack();
}, 5000);

function startHack() {
    isHacking = true;
    term.style.display = 'block';
    currentCommand = commands[Math.floor(Math.random() * commands.length)];
    promptEl.innerText = "TYPE: " + currentCommand;
    input.value = "";
    input.focus();
    document.getElementById('mode').innerText = "BREACH_DETECTED";
}

input.addEventListener('input', () => {
    if (input.value.toUpperCase() === currentCommand) {
        completeHack();
    }
});

function completeHack() {
    isHacking = false;
    term.style.display = 'none';
    shockwave.active = true;
    shockwave.r = 0;
    shockwave.x = player.x;
    shockwave.y = player.y;
    score += 500;
    document.getElementById('mode').innerText = "STABLE";
}

function update() {
    if (!isHacking) {
        // Player follows mouse
        canvas.onmousemove = (e) => {
            player.x += (e.clientX - player.x) * 0.15;
            player.y += (e.clientY - player.y) * 0.15;
        };

        enemies.forEach((en, i) => {
            en.x += en.vx; en.y += en.vy;
            // Wrap screen
            if (en.x < 0) en.x = canvas.width;
            if (en.x > canvas.width) en.x = 0;
            if (en.y < 0) en.y = canvas.height;
            if (en.y > canvas.height) en.y = 0;

            // Collision
            let d = Math.hypot(player.x - en.x, player.y - en.y);
            if (d < 15) {
                alert("SYSTEM FAILURE. Final Score: " + score);
                location.reload();
            }
        });
    }

    if (shockwave.active) {
        shockwave.r += 20;
        enemies = enemies.filter(en => {
            let d = Math.hypot(shockwave.x - en.x, shockwave.y - en.y);
            return d > shockwave.r;
        });
        if (shockwave.r > canvas.width) shockwave.active = false;
    }

    if (Math.random() < 0.05) spawnEnemy();
}

function draw() {
    // Background
    ctx.fillStyle = isHacking ? "#110011" : "#050508";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Shockwave effect
    if (shockwave.active) {
        ctx.strokeStyle = "white";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(shockwave.x, shockwave.y, shockwave.r, 0, Math.PI * 2);
        ctx.stroke();
        
        // Flash effect
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
        ctx.fillRect(0,0, canvas.width, canvas.height);
    }

    // Player
    ctx.shadowBlur = 15;
    ctx.shadowColor = "white";
    ctx.fillStyle = "white";
    ctx.fillRect(player.x - 5, player.y - 5, 10, 10);

    // Enemies
    ctx.shadowColor = varColor('--pink');
    ctx.fillStyle = varColor('--pink');
    enemies.forEach(en => ctx.fillRect(en.x - 3, en.y - 3, 6, 6));
    
    ctx.shadowBlur = 0;
}

function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name); }

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
